function defaults = getBlinkerDefaults(signal)
% Returns the defaults for blinker as a structure
%
% Parameters:
%     signal       (optional) a structure compatible with EEGLAB EEG structure
%                   (must have .data, .srate, .filepath, and filename fields
% Output:
%     defaults     a structure with the parameters for the default types
%                  in the form of a structure that has fields
%                     value: default value
%                     classes:   classes that the parameter belongs to
%                     attributes:  attributes of the parameter
%                     description: description of parameter
%
% BLINKER extracts blinks and ocular indices from time series. 
% Copyright (C) 2016  Kay A. Robbins, Kelly Kleifgas, UTSA
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

if nargin < 1
    theName = 'Unknown';
    fileName = 'Unknown';
    srate = 1;
    channels = 1;
else
    fileName = [signal.filepath signal.filename];
    [~, theName, ~] = fileparts(fileName);
    srate = signal.srate;
    channels = size(signal.data, 1);
end
    

defaults = struct( ...
    'srate', ...
    getRules(srate, {'numeric'}, ...
    {'positive', 'scalar'}, ...
    'Sampling rate of the signal in Hz.'), ...
    'stdThreshold', ...
    getRules(1.5, {'numeric'}, ...
    {'positive', 'scalar'}, ...
    'Number of robust stds above mean for potential blinks.'), ...
    'subjectID', ...
    getRules('Subject1_Task1_Experiment1_Rep1', {'char'}, ...
    {}, ...
    'Subject ID for the dataset.'), ...
    'uniqueName', ...
    getRules('Unknown', {'char'}, ...
    {}, ...
    'Unique name identifying this dataset'), ...
    'experiment', ...
    getRules('Experiment1', {'char'}, ...
    {}, ...
    'String identifying the experiment'), ...
    'task', ...
    getRules('Task1', {'char'}, ...
    {}, ...
    'Name of task performed in this dataset'), ...
    'startDate', ...
    getRules('01-Jan-2016', {'char'}, ...
    {}, ...
    'Start date of dataset in dd-mmm-yyyy format'), ...
    'startTime', ...
    getRules('00:00:00', {'char'}, ...
    {}, ...
    'Start time in 24 hour hh:mm:ss format.'), ...
    'signalTypeIndicator', ...
    getRules('UseNumbers', {'char'}, {}, ...
    ['Specifies how to identify the signals from which to extract blinks: ' ...
     '(UseNumbers|UseLabels|UseICs).']), ...
    'signalNumbers', ...
     getRules(1:channels, {'numeric'}, ...
     {'row', 'positive', 'integer', '<=', channels}, ...
    'Vector of numbers of the s to try if signalTypeIndicator is UseNumbers.'), ...
    'signalLabels', ...
    getRules({'fp1', 'f1', 'fp2', 'fz', 'fpz', 'f3', 'f4', 'f2'}, {'char', 'cell'}, {}, ...
     'Specifies the signal labels to use'), ...
     'excludeLabels', ...
    getRules({'exg5', 'exg6', 'exg7', 'exg8', 'vehicle position'}, {'char', 'cell'}, {}, ...
     'Specifies the signal labels to exclude'), ...
    'dumpBlinkerStructures', ...
    getRules(true, {'logical'}, {}, ...
    'If true, dump all of the blinker structure files.'), ...
    'showMaxDistribution', ...
    getRules(true, {'logical'}, {}, ...
    'If true, blinker shows distribution of blink maxima.'), ...
    'dumpBlinkImages', ...
    getRules(false, {'logical'}, {}, ...
    'If true, blinker dumps pictures of the individual blinks.'), ...
    'verbose', ...
    getRules(true, {'logical'}, {}, ...
    'If true, blinker outputs various informative messages and statistics.'), ...
    'dumpBlinkPositions', ...
    getRules(false, {'logical'}, {}, ...
    'If true, blinker dumps a text file of left zeros and maxima frames and times.'), ...
    'fileName', ...
    getRules(fileName, {'char'}, {}, ...
    'Full path name of the input EEG file.'), ...
    'blinkerSaveFile', ...
     getRules([pwd filesep theName '_blinks.mat'], {'char'}, ...
    {}, ...
    'Name of file for saving the structures of blink locations and properties'), ...
    'blinkerDumpDir', ...
    getRules([pwd filesep 'blinkDump'], {'char'}, {}, ...
    'Name of directory in which to dump pictures of blinks.'), ...
    'lowCutoffHz', ...
     getRules(1, {'numeric'}, {'scalar', 'nonnegative'}, ...
       'Lower edge of bandpass filter'), ...
    'highCutoffHz', ...
     getRules(20, {'numeric'}, {'scalar', 'positive'}, ...
       'Upper edge of bandpass filter'),  ...
    'minGoodBlinks', ...
     getRules(10, {'numeric'}, {'scalar', 'nonnegative'}, ...
       'Minimum number of good blinks for signal to be a candidate'),  ...
     'blinkAmpRange', ...
     getRules([3, 50], {'numeric'}, {'row', 'positive', 'numel', 2}, ...
     'Range of blink amplitude ratios allowed for candidate signals'),  ...
    'goodRatioThreshold', ...
     getRules(0.7, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...
       'Minimum number of good blinks for signal to be a candidate'),  ...
     'pAVRThreshold', ...
     getRules(3, {'numeric'}, {'scalar', 'positive'}, ...
       'Minimum number of good blinks for signal to be a candidate'),  ...
     'correlationThresholdTop', ...
     getRules(0.98, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...
       'Correlation threshold for linear fits of best blinks'),  ...
     'correlationThresholdBottom', ...
     getRules(0.90, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...
       'Correlation threshold for linear fits of acceptable blinks'),  ...
     'correlationThresholdMiddle', ...
     getRules(0.95, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...
       'Correlation threshold middle range in displaying blink maxima'),  ...
     'keepSignals', ...
     getRules(false, {'logical'}, {}, ...
       ['Keep signals that pass the blink amplitude ratio test' ...
       ' regardless of good ratio (for combination)']),  ...  
     'shutAmpFraction', ...
      getRules(0.90, {'numeric'}, {'scalar', 'nonnegative', '<=', 1}, ...
       'Fraction of maximum amplitude to reach for time shut'),  ...
     'zThresholds', ...
     getRules([0.90, 2; 0.98, 5], {'numeric'}, {'positive', 'ncols', 2}, ...
     'Rows contain correlation and max z-score threshold pairs for determining good blinks'), ...
     'ICSimilarityThreshold', ...
     getRules(0.85, {'numeric'}, {'nonnegative', '<=', 1}, ...
     'How similar and IC has to be to an eye IC to be a candidate'), ...
     'ICFOMThreshold', ...
     getRules(1, {'numeric'}, {'positive'}, ...
     'Mean difference in IC scalp map amplitude of front versus rear hemispheres'), ...
     'numberMaxBins', ...
      getRules(80, {'numeric'}, {'positive'}, ...
     'Number of bins used to display histograms of blink maxima') ...
 );
end

function s = getRules(value, classes, attributes, description)
% Construct the default structure
s = struct('value', [], 'classes', [], ...
    'attributes', [], 'description', []);
s.value = value;
s.classes = classes;
s.attributes = attributes;
s.description = description;
end